# Buffer Overflow Exploit Analysis

## Overview

This document explains the buffer overflow vulnerability observed in the `tcpserver-basic` program running on port 40000, which resulted in a segmentation fault after receiving 516 bytes of data.

## Vulnerability Analysis

The vulnerability exists in the `handle_client` function of the server code:

```c
void handle_client(int client_sock) {
    char buffer[BUFFER_SIZE];  // BUFFER_SIZE is defined as 128
    ssize_t bytes_received;
    
    /* Clear the buffer */
    memset(buffer, 0, BUFFER_SIZE);
    
    /* Receive data from client - VULNERABLE: no size checking */
    bytes_received = recv(client_sock, buffer, 1024, 0);  // Deliberately receiving more than buffer size
    
    // ...
}
```

The vulnerability occurs because:
1. The buffer is only 128 bytes in size
2. The `recv()` function is allowed to receive up to 1024 bytes
3. There is no bounds checking, allowing a buffer overflow

When the server received 516 bytes, it crashed with a segmentation fault, indicating that the return address on the stack was overwritten with an invalid memory address.

## Exploit Tools

Two exploit scripts have been created to analyze and exploit this vulnerability:

### 1. exploit-buffer-overflow.py

A basic exploit script that includes:
- Pattern generation for finding the exact offset to the return address
- Payload creation with shellcode
- Functions to send specific-sized payloads for testing

### 2. exploit-tcpserver-40000.py

A more comprehensive exploit script specifically targeting the server on port 40000:
- Enhanced pattern analysis
- Incremental crash analysis to pinpoint the exact crash point
- Interactive shell functionality for successful exploits
- Multiple modes for different testing scenarios

## Usage Instructions

### Prerequisites

1. Disable ASLR (Address Space Layout Randomization) on the target system:
   ```
   echo 0 > /proc/sys/kernel/randomize_va_space
   ```

2. Ensure the vulnerable server is running on port 40000:
   ```
   ./tcpserver-basic 40000
   ```

### Finding the Exact Offset

1. Send a pattern to find the exact offset:
   ```
   python3 exploit-tcpserver-40000.py pattern
   ```

2. Check the crash information to find the value in EIP:
   ```
   dmesg | tail
   ```

3. Find the offset of that value in the pattern:
   ```
   python3 exploit-tcpserver-40000.py offset <EIP_VALUE>
   ```

### Analyzing the Crash

To incrementally test different payload sizes and narrow down the exact crash point:
```
python3 exploit-tcpserver-40000.py analyze
```

### Exploiting the Vulnerability

Once you've determined the exact offset, run the exploit:
```
python3 exploit-tcpserver-40000.py exploit <OFFSET>
```

If successful, you should get a shell prompt where you can enter commands.

## Mitigation Strategies

To fix this vulnerability, the server code should be modified to:

1. Limit the amount of data received to the buffer size:
   ```c
   bytes_received = recv(client_sock, buffer, BUFFER_SIZE - 1, 0);
   ```

2. Implement proper bounds checking

3. Enable stack protection mechanisms:
   - Compile with stack canaries: remove `-fno-stack-protector`
   - Use non-executable stack: remove `-z execstack`
   - Enable ASLR

## Advanced Exploitation (Non-Executable Stack)

For systems with non-executable stack protection, the `exploit-rop.py` script demonstrates a Return-Oriented Programming (ROP) approach to bypass this protection by chaining together existing code fragments (gadgets) to execute system calls.

## Educational Purpose

These exploits are provided for educational purposes only to understand buffer overflow vulnerabilities and protection mechanisms. Use only on systems you have permission to test.